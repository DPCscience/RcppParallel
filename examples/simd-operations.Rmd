---
title: "SIMD Operations"
author: "Kevin Ushey"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SIMD Operations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## SIMD Basics

Modern CPU processors are built with new, extended
instruction sets that optimize for certain operations. A
class of these allow for vectorized operations, called
Single Instruction / Multiple Data (SIMD) instructions. 
Although modern compilers will use these instructions when
possible, they are often unable to reason about whether or
not a particular block of code can be executed using SIMD
instructions.

`Boost.SIMD` is a C++ header-only library that makes it
possible to explicitly request the use of SIMD instructions
when possible, while falling back to regular scalar
operations if not. `RcppParallel` wraps and exposes this
library for use with R vectors.

Here's a quick example of how we might compute the sum of
elements in a vector, using `Boost.SIMD`.

```{r, engine='Rcpp'}
// [[Rcpp::depends(RcppParallel)]]
#define RCPP_PARALLEL_USE_SIMD
#include <RcppParallel.h>
using namespace RcppParallel;

#include <Rcpp.h>
using namespace Rcpp;

// Define a functor -- a C++ class which defines a templated 'function call' 
// operator -- to perform the addition of two pieces of data.
struct add_two {
   template <typename T>
   T operator()(const T& lhs, const T& rhs) {
      return lhs + rhs;
   }
};

// [[Rcpp::export]]
double simd_sum(NumericVector x) {
   return simdReduce(x.begin(), x.end(), 0.0, add_two());
}
```

```{r}
data <- rnorm(1024 * 1000)
all.equal(simd_sum(data), sum(data))
if (requireNamespace("microbenchmark", quietly = TRUE)) {
   microbenchmark::microbenchmark(sum(data), simd_sum(data))
}
```


## SIMD Algorithms

`Boost.SIMD` provides two primary abstractions for the
implementation of SIMD algorithms:

- `boost::simd::transform()`  --- for vector -> vector transformations, and
- `boost::simd::accumulate()` --- for vector -> scalar transformations.

These functions operate like their `std::` counterparts, but
expect a functor with a templated call operator. By making
the call operator templated, `Boost.SIMD` can generate code
using its own optimized SIMD functions when appropriate, and
fall back to a default implementation (based on the types
provided) when not.

`RcppParallel` augments this with its own algorithms as well,
for consistency with `parallelFor()` and `parallelReduce()`:

- `RcppParallel::simdFor()`    --- apply an operation over a range, and
- `RcppParallel::simdReduce()` --- accumulate elements in a range.
   
## Using SIMD in an R Package

To build an R package that uses `Boost.SIMD`, you need to
make some modifications to the standard RcppParallel 
configuration. Within the `DESCRIPTION` file of your package,
you need to:

1. Add the **BH** package as a `LinkingTo` dependency, and
2. Add `C++11` as a `SystemRequirement`

### Platform Compatibility

`Boost.SIMD` requires a C++11 conformant compiler. This
means that packages making use of SIMD features may not 
compile on platforms with older compilers, including Windows 
and RedHat/CentOS Linux. You can however create a package 
that takes advantage of `Boost.SIMD` where available and falls
back to a non-SIMD implementation otherwise.

You can opt-in to the use of `Boost.SIMD` by defining the 
`RCPP_PARALLEL_USE_SIMD` macro before including
`<RcppParallel.h>`, e.g.

    #define RCPP_PARALLEL_USE_SIMD
    
You can test for the availability of `Boost.SIMD` on a given
platform using the `RCPP_PARALLEL_USE_SIMD` preprocessor
variable. If the current compiler doesn't support C++11 (as
determined by `__cplusplus <= 199711L`) the variable will be
undefined (even if you defined it explicitly). This allows
you to write code like this:

```cpp
#define RCPP_PARALLEL_USE_SIMD
#include <RcppParallel.h>

#if RCPP_PARALLEL_USE_SIMD

IntegerVector transformDataImpl(IntegerVector x) {
  // Implement with Boost.SIMD
}

#else

IntegerVector transformDataImpl(IntegerVector x) {
  // Implement without Boost.SIMD
}

#endif

// [[Rcpp::export]]
IntegerVector transformData(IntegerVector x) {
   return transformDataImpl(x);
}

```

The two `transformDataImpl` functions have the same name,
but only one will be compiled and linked based on whether
the target platform supports `Boost.SIMD`.

Note that if you conditionally compile all uses of
`Boost.SIMD` within your package, then you can drop
the `C++11` from `SystemRequirements` (it's no longer
required as a result of your fallback implementation).



   





