<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />



<title></title>

<script src="index_files/jquery-1.11.0/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="index_files/bootstrap-3.3.1/css/cosmo.min.css" rel="stylesheet" />
<script src="index_files/bootstrap-3.3.1/js/bootstrap.min.js"></script>
<script src="index_files/bootstrap-3.3.1/shim/html5shiv.min.js"></script>
<script src="index_files/bootstrap-3.3.1/shim/respond.min.js"></script>

<link href="libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet">

<script src="libs/tocify-1.9.1/jquery-ui-1.9.2.custom.min.js"></script>
<script src="libs/tocify-1.9.1/jquery.tocify.min.js"></script>

<style type="text/css">
@media (max-width: 992px) {
#toc {
  position: relative;
  width: 100%;
  margin: 0px 0px 20px 0px;
}
}
</style>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="index_files/highlight/textmate.css"
      type="text/css" />
<script src="index_files/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img { 
  max-width:100%; 
  height: auto; 
}
</style>
<div class="container-fluid main-container">


<div class="row-fluid">

<div class="span3 col-md-3">
  <div id="toc"></div>
</div>

<div class="main-content span9 col-md-9">

<style type="text/css">
body {
  padding-top: 20px;
}
/* offset scroll position for anchor links */
h3 {
  padding-top: 25px;
  margin-top: -25px;
}
h4 {
  padding-top: 25px;
  margin-top: -25px;
}

.main-content {
  padding-left: 30px;
  padding-right: 40px;
}

.section {
  margin-bottom: 25px;
}

.tocify {
  border: none;
  background-color: #ECF2F6;
  margin-top: 10px;
}

.tocify .list-group-item {
  border-radius: 0px;
  background-color: #ECF2F6;
  padding-top: 0px;
  padding-bottom: 0px;
  color: #3676BD;
}

.tocify .list-group-item.active {
  color: white;
  background-color: #428DC8;
}

.tocify .list-group-item:hover {
  background-color: #caddec;
}

.tocify .list-group-item.active:hover {
  color: white;
  background-color: #428DC8;
}

.tocify-subheader {
  display: inline;
}

.tocify-subheader .tocify-item {
  font-size: 0.95em;
  padding-left: 12px;
}

#overview h3 {
  visibility: hidden;
  height: 0px;
}

blockquote {
  font-size: 1em;
}

</style>



<div id="overview" class="section level3">
<h3>Overview</h3>
<p><img src="images/RcppParallelLogo.png" width="643" height="90"></img></p>
<p>RcppParallel provides a complete toolkit for creating portable, high-performance parallel algorithms without requiring direct manipulation of operating system threads. RcppParallel includes:</p>
<ul>
<li><p><a href="https://www.threadingbuildingblocks.org/">Intel Thread Building Blocks</a>, a C++ library for task parallelism with a wide variety of parallel algorithms and data structures (Windows, OS X, and Linux only).</p></li>
<li><p><a href="http://tinythreadpp.bitsnbites.eu/">TinyThread</a>, a C++ library for portable use of operating system threads.</p></li>
<li><p><code>RVector</code> and <code>RMatrix</code> wrapper classes for safe and convenient access to R data structures in a multi-threaded environment.</p></li>
<li><p>High level parallel functions (<code>parallelFor</code> and <code>parallelReduce</code>) that use Intel TBB as a back-end on systems that support it and TinyThread on other platforms.</p></li>
</ul>
<p>In many cases, RcppParallel can achieve significantly better performance than traditional use of threads or even <a href="http://openmp.org/wp/">OpenMP</a>. This is accomplished via dynamic task scheduling that attempts to optimize locality of reference (and therefore cache hit rates) as well as work stealing (detecting idle threads and pushing work to them).</p>
</div>
<div id="getting-started" class="section level3">
<h3>Getting Started</h3>
<p>You can install the RcppParallel package from CRAN as follows:</p>
<pre class="s"><code>install.packages(&quot;RcppParallel&quot;)</code></pre>
<div id="sourcecpp" class="section level4">
<h4>sourceCpp</h4>
<p>Add the following to a standalone C++ source file to import RcppParallel:</p>
<pre class="cpp"><code>// [[Rcpp::depends(RcppParallel)]]
#include &lt;RcppParallel.h&gt;</code></pre>
<p>When you compile the file using <code>Rcpp::sourceCpp</code> the required compiler and linker settings for RcppParallel will be automatically included in the compilation.</p>
</div>
<div id="r-packages" class="section level4">
<h4>R Packages</h4>
<p>If you want to use RcppParallel from within an R package you need to edit several files to create the requisite build and runtime links. The following additions should be made:</p>
<p><strong>DESCRIPTION</strong></p>
<pre class="yaml"><code>Imports: RcppParallel
LinkingTo: RcppParallel</code></pre>
<p><strong>NAMESPACE</strong></p>
<pre class="r"><code>importFrom(RcppParallel, RcppParallelLibs)</code></pre>
<p><strong>src\Makevars.win</strong></p>
<pre class="make"><code>PKG_CXXFLAGS += -DRCPP_PARALLEL_USE_TBB=1

PKG_LIBS += $(shell &quot;${R_HOME}/bin${R_ARCH_BIN}/Rscript.exe&quot; \
              -e &quot;RcppParallel::RcppParallelLibs()&quot;)</code></pre>
<p>Then in each source file that needs to use RcppParallel include the main package header:</p>
<pre class="cpp"><code>#include &lt;RcppParallel.h&gt;</code></pre>
</div>
<div id="examples" class="section level4">
<h4>Examples</h4>
<p>You may want to get started by reviewing some examples (links to several are provided below). Even if you get the hang of things by looking at examples, it’s still highly recommended that you review this guide as it has important content about thread safety, tuning, and more advanced uses of TBB.</p>
<p><a href="http://gallery.rcpp.org/articles/parallel-matrix-transform/">Parallel Matrix Transform</a> — Demonstrates using <code>parallelFor</code> to transform a matrix (take the square root of each element) in parallel. In this example the parallel version performs about 2.5x faster than the serial version.</p>
<p><a href="http://gallery.rcpp.org/articles/parallel-vector-sum/">Parallel Vector Sum</a> — Demonstrates using <code>parallelReduce</code> to take the sum of a vector in parallel. In this example the parallel version performs 4.5x faster than the serial version.</p>
<p><a href="http://gallery.rcpp.org/articles/parallel-distance-matrix/">Parallel Distance Matrix</a> — Demonstrates using <code>parallelFor</code> to compute pairwise distances for each row in an input data matrix. In this example the parallel version performs 5.5x faster than the serial version.</p>
<p><a href="http://gallery.rcpp.org/articles/parallel-inner-product/">Parallel Inner Product</a> — Demonstrates using <code>parallelReduce</code> to compute the inner product of two vectors in parallel. In this example the parallel version performs 2.5x faster than the serial version.</p>
<p>Note that performance benchmarks were executed on a 2.6GHz Haswell MacBook Pro with 4 cores (8 with hyperthreading).</p>
</div>
</div>
<div id="thread-safety" class="section level3">
<h3>Thread Safety</h3>
<p>A major goal of RcppParallel is to make it possible to write parallel code without traditional threading and locking primitives (which are notoriously complicated and difficult to get right). This is achieved for the most part by <code>parallelFor</code> and <code>parallelReduce</code> however the fact that the R API itself is single-threaded must also be taken into consideration.</p>
<div id="api-restrictions" class="section level4">
<h4>API Restrictions</h4>
<p>The code that you write within parallel workers should not call the R or Rcpp API in any fashion. This is because R is single-threaded and concurrent interaction with it’s data structures can cause crashes and other undefined behavior. Here is the official guidance from <a href="http://cran.rstudio.com/doc/manuals/r-release/R-exts.html">Writing R Extensions</a>:</p>
<blockquote>
<p>Calling any of the R API from threaded code is ‘for experts only’: they will need to read the source code to determine if it is thread-safe. In particular, code which makes use of the stack-checking mechanism must not be called from threaded code.</p>
</blockquote>
<p>Not being able to call the R or Rcpp API creates an obvious challenge: how to read and write to R vectors and matrices. Fortunately, R vectors and matrices are just contiguous arrays of <code>int</code>, <code>double</code>, etc. so can be accessed using traditional array and pointer offsets. The next section describes a safe and high level way to do this.</p>
</div>
<div id="safe-accessors" class="section level4">
<h4>Safe Accessors</h4>
<p>To provide safe and convenient access to the arrays underlying R vectors and matrices RcppParallel introduces several accessor classes:</p>
<ul>
<li><p><code>RVector&lt;T&gt;</code> — Wrap R vectors of various types</p></li>
<li><p><code>RMatrix&lt;T&gt;</code> — Wrap R matrices of various types (also includes <code>Row</code> and <code>Column</code> classes)</p></li>
</ul>
<p>To create a thread safe accessor for an Rcpp vector or matrix just construct an instance of <code>RVector</code> or <code>RMatrix</code> with it. For example:</p>
<pre class="cpp"><code>// [[Rcpp::export]]
IntegerVector transformVector(IntegerVector x) {
  RVector&lt;int&gt; input(x);
  // etc...
}</code></pre>
<p>Similarly, if you need to return a vector as a result of a parallel transformation you should first create it using Rcpp then construct a wrapper for writing from multiple threads. For example:</p>
<pre class="cpp"><code>// [[Rcpp::export]]
IntegerVector transformVector(IntegerVector x) {
  RVector&lt;int&gt; input(x);        // create threadsafe wrapper to input
  IntegerVector y(x.size());    // allocate output vector
  RVector&lt;int&gt; output(y);       // create threadsafe wrapper to output
  
  // ...transform vector in parallel ...
  
  return y;
}</code></pre>
</div>
<div id="locking" class="section level4">
<h4>Locking</h4>
<p>When using RcppParallel you typically do not need to worry about explicit locking, as the mechanics of <code>parallelFor</code> and <code>parallelReduce</code> (explained below) take care of providing safe windows into input and output data that have no possibility of contention. Nevertheless, if for some reason you do need to synchronize access to shared data, you can use the TinyThread locking classes (automatically available via <code>RcppParallel.h</code>). See the <a href="http://tinythreadpp.bitsnbites.eu/doc/">TinyThread documentation</a> for additional details.</p>
</div>
</div>
<div id="algorithms" class="section level3">
<h3>Algorithms</h3>
<p>RcppParallel provides two high level parallel algorithms: <code>parallelFor</code> can be used to convert the work of a standard serial “for” loop into a parallel one and <code>parallelReduce</code> can be used for accumulating aggregate or other values.</p>
<div id="parallelfor" class="section level4">
<h4>parallelFor</h4>
<p>To use <code>parallelFor</code>, you create a <code>Worker</code> object that defines an <code>operator()</code> which is called by the parallel scheduler. This function is passed begin/end ranges which are safe windows (i.e. not in use by other threads) into the input or output data. For example, here’s a <code>Worker</code> object that takes the square root of it’s input and writes it into it’s output:</p>
<pre class="cpp"><code>// [[Rcpp::depends(RcppParallel)]]
#include &lt;RcppParallel.h&gt;
using namespace RcppParallel;

struct SquareRoot : public Worker
{
   // source matrix
   const RMatrix&lt;double&gt; input;
   
   // destination matrix
   RMatrix&lt;double&gt; output;
   
   // initialize with source and destination
   SquareRoot(const NumericMatrix input, NumericMatrix output) 
      : input(input), output(output) {}
   
   // take the square root of the range of elements requested
   void operator()(std::size_t begin, std::size_t end) {
      std::transform(input.begin() + begin, 
                     input.begin() + end, 
                     output.begin() + begin, 
                     ::sqrt);
   }
};
</code></pre>
<p>Note that <code>SquareRoot</code> derives from <code>RcppParallel::Worker</code>. This is required for function objects passed to <code>parallelFor</code>.</p>
<p>Here’s a function that calls the <code>SquareRoot</code> worker we defined:</p>
<pre class="cpp"><code>// [[Rcpp::export]]
NumericMatrix parallelMatrixSqrt(NumericMatrix x) {
  
  // allocate the output matrix
  NumericMatrix output(x.nrow(), x.ncol());
  
  // SquareRoot functor (pass input and output matrixes)
  SquareRoot squareRoot(x, output);
  
  // call parallelFor to do the work
  parallelFor(0, x.length(), squareRoot);
  
  // return the output matrix
  return output;
}</code></pre>
</div>
<div id="parallelreduce" class="section level4">
<h4>parallelReduce</h4>
<p>To use <code>parallelReduce</code> you create a <code>Worker</code> object as well, this object should include:</p>
<ol style="list-style-type: decimal">
<li><p>A standard and “splitting” constructor. The standard constructor takes the input data and initializes whatever value is being accumulated (e.g. initialize a sum to zero). The splitting constructor is called when work needs to be split onto other threads—it takes a reference to the instance it is being split from and simply copies the pointer to the input data and initializes it’s “accumulated” value to zero.</p></li>
<li><p>An operator() which performs the work. This works just like the operator() in <code>parallelFor</code>, but instead of writing to another vector or matrix it typically will accumulate a value.</p></li>
<li><p>A join method which composes the operations of two worker instances that were previously split. Here we simply combine the accumulated value of the instance we are being joined with to our own.</p></li>
</ol>
<p>For example, here’s a <code>Worker</code> object that is used to sum a vector:</p>
<pre class="cpp"><code>// [[Rcpp::depends(RcppParallel)]]
#include &lt;RcppParallel.h&gt;
using namespace RcppParallel;

struct Sum : public Worker
{   
   // source vector
   const RVector&lt;double&gt; input;
   
   // accumulated value
   double value;
   
   // constructors
   Sum(const NumericVector input) : input(input), value(0) {}
   Sum(const Sum&amp; sum, Split) : input(sum.input), value(0) {}
   
   // accumulate just the element of the range I&#39;ve been asked to
   void operator()(std::size_t begin, std::size_t end) {
      value += std::accumulate(input.begin() + begin, input.begin() + end, 0.0);
   }
     
   // join my value with that of another Sum
   void join(const Sum&amp; rhs) { 
      value += rhs.value; 
   }
};</code></pre>
<p>Now that we’ve defined the Worker, implementing the parallel sum function is straightforward. Just initialize an instance of <code>Sum</code> with an input vector and call <code>parallelReduce</code>:</p>
<pre class="cpp"><code>// [[Rcpp::export]]
double parallelVectorSum(NumericVector x) {
   
   // declare the Sum instance 
   Sum sum(x);
   
   // call parallel_reduce to start the work
   parallelReduce(0, x.length(), sum);
   
   // return the computed sum
   return sum.value;
}</code></pre>
</div>
</div>
<div id="tuning" class="section level3">
<h3>Tuning</h3>
<p>There are several settings available for tuning the behavior of parallel algorithms. These settings as well as benchmarking techniques are covered below.</p>
<div id="grain-size" class="section level4">
<h4>Grain Size</h4>
<p>The grain size of a parallel algorithm sets a minimum chunk size for parallelization. In other words, at what point to stop processing input on separate threads (as sometimes creating more threads can degrade the performance of an algorithm by introducing excessive synchronization overhead).</p>
<p>By default the grain size for TBB (and thus for <code>parallelFor</code> and <code>parallelReduce</code>) is 1. You can change the grain size by passing an additional parameter to these functions. For example:</p>
<pre class="cpp"><code>parallelReduce(0, x.length(), sum, 100);</code></pre>
<p>This will prevent the creation of threads that process less than 100 items. You should experiment with various chunk sizes and use the benchmarking tools described below to measure their effectiveness. The Intel TBB website includes a detailed <a href="https://www.threadingbuildingblocks.org/docs/help/tbb_userguide/Controlling_Chunking.htm">discussion of grain sizes and partitioning</a> which has some useful guidelines for tweaking grain sizes.</p>
</div>
<div id="threads-used" class="section level4">
<h4>Threads Used</h4>
<p>By default all of the available cores on a machine are used for parallel algorithms. You may instead want to use a fixed number of threads or a fixed proportion of cores available on the machine.</p>
<p>R rather than C++ functions are provided to control these settings so that users of your algorithm can control the use of resources on their system. You can call the <code>setNumThreads</code> function to allocate threads. For example, the following sets a maximum of 4 threads:</p>
<pre class="r"><code>RcppParallel::setNumThreads(4)</code></pre>
<p>To use a proportion of available cores you can use the <code>defaultNumThreads</code> function. For example, the following says to use half of the available cores on a system:</p>
<pre class="r"><code>library(RcppParallel)
setNumThreads(defaultNumThreads() / 2)</code></pre>
</div>
<div id="benchmarking" class="section level4">
<h4>Benchmarking</h4>
<p>As you experiment with various settings to tune your parallel algorithms you should always measure the results. The <strong>rbenchmark</strong> package has some useful tools for doing this. For example, here’s a benchmark of the parallel matrix square root example from above (in this case it’s a comparison against the serial version):</p>
<pre class="r"><code># allocate a matrix
m &lt;- matrix(as.numeric(c(1:1000000)), nrow = 1000, ncol = 1000)

# ensure that serial and parallel versions give the same result
stopifnot(identical(matrixSqrt(m), parallelMatrixSqrt(m)))

# compare performance of serial and parallel
library(rbenchmark)
res &lt;- benchmark(matrixSqrt(m),
                 parallelMatrixSqrt(m),
                 order=&quot;relative&quot;)
res[,1:4]</code></pre>
<pre><code>                   test replications elapsed relative
2 parallelMatrixSqrt(m)          100   0.294    1.000
1         matrixSqrt(m)          100   0.755    2.568</code></pre>
</div>
</div>
<div id="using-tbb" class="section level3">
<h3>Using TBB</h3>
<p>RcppParallel provides the <code>parallelFor</code> and <code>parallelReduce</code> functions however the TBB library includes a wealth of other tools for parallelization. The motivation for <code>parallelFor</code> and <code>parallelReduce</code> is portability: you can write a single algorithm that uses TBB on Windows, OS X, and Linux but falls back to a lower-performance implementation based on TinyThread on other platforms.</p>
<p>If however you are okay with targeting only Windows, OS X, and Linux, you can use TBB directly and bypass <code>parallelFor</code> and <code>parallelReduce</code>. Note that if you are doing this within an R package you plan on submitting to CRAN you should also provide a fallback serial implementation so the package still compiles on other platforms (details on doing this are in the <em>Portability</em> section below).</p>
<div id="tbb-apis" class="section level4">
<h4>TBB APIs</h4>
<p>TBB includes a wide variety of tools for parallel programming, including:</p>
<ul>
<li>Advanced algorithms: <code>parallel_scan</code>, <code>parallel_while</code>, <code>parallel_do</code>, <code>parallel_pipeline</code>, <code>parallel_sort</code></li>
<li>Containers: <code>concurrent_queue</code>, <code>concurrent_priority_queue</code>, <code>concurrent_vector</code>, <code>concurrent_hash_map</code></li>
<li>Mutual exclusion: <code>mutex</code>, <code>spin_mutex</code>, <code>queuing_mutex</code>, <code>spin_rw_mutex</code>, <code>queuing_rw_mutex</code>, <code>recursive_mutex</code></li>
<li>Atomic operations: <code>fetch_and_add</code>, <code>fetch_and_increment</code>, <code>fetch_and_decrement</code>, <code>compare_and_swap</code>, <code>fetch_and_store</code></li>
<li>Timing: portable fine grained global time stamp</li>
<li>Task Scheduler: direct access to control the creation and activation of tasks</li>
</ul>
<p>See the <a href="https://software.intel.com/en-us/node/506045">Intel TBB User Guide</a> for documentation on using these features.</p>
</div>
<div id="portability" class="section level4">
<h4>Portability</h4>
<p>When using TBB directly in a CRAN package you should check the value of the <code>RCPP_PARALLEL_USE_TBB</code> macro and conditionally include a serial implementation of your algorithm if it’s not <code>TRUE</code>. Note that this macro is defined in <code>RcppParallel.h</code> so you should include this in all cases (it will in turn automatically include <code>&lt;tbb/tbb.h&gt;</code> on platforms where it’s supported). For example, your source file might look like this:</p>
<pre class="cpp"><code>#include &lt;RcppParallel.h&gt;

#if RCPP_PARALLEL_USE_TBB

IntegerVector transformData(IntegerVector x) {

  // Implement by calling TBB APIs directly 

}

#else

IntegerVector transformData(IntegerVector x) {

  // Implement serially

}

#endif</code></pre>
<p>Note that the two functions have the same name (only one will be compiled and linked based on whether the target platform supports TBB).</p>
</div>
</div>


</div> <!--span-9-->
</div> <!--row-fluid-->

<style type="text/css">
.main-container {
  max-width: none;
}
</style>

<script>
$(function() {
    var toc = $("#toc").tocify({
      selectors: "h3,h4",
      theme: "bootstrap3",
      context: '.main-content',
      hashGenerator: 'pretty',
      showAndHide: false
    }).data("toc-tocify");
    $(".optionName").popover({ trigger: "hover" });
});
</script>

</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
